import { getTheme } from "./asterism";

export function buildPluginPhp(): string {
	const { name, namespace, author, authorUri, version } = getTheme();

	var pluginTxt = `/** \n` +
		`* Plugin Name: ${name} - Support Plugin\n` +
		`* description: This plugin is used to support the ${name} theme.\n` +
		`* Version: ${version || '0.0.1'}\n` +
		`* Author: ${author}\n` +
		`* Author URI: ${authorUri}\n` +
		`* \n` +
		`* @package ${namespace}\n` +
		`*/\n`;

	return pluginTxt;
}

/**
 * Generates post type registration for the given post types
 * @param postTypes An array of post types
 * @param textDomain The text domain to use for translation
 * @returns A string containing the post type registration code
 */
export function generatePostTypes(postTypes: PostType[], textDomain: string) {
	let output = '/** Post Types Genearted by Asterism\n' +
		' * DO NOT EDIT THIS FILE \n' +
		' */\n\n';

	if (postTypes) {
		output += postTypes.map((postType) => {
			return `// Post Type: ${postType.name}\n` +
				`add_action('init', function() {\n` +
				`  register_post_type('${postType.name}', [\n` +
				`    'label' => _x('${postType.name}', 'Post Type General Name', '${textDomain}'),\n` +
				(postType.labels ? `    'labels' => [\n` : '') +
				(postType.labels?.name ? `   	  'name' => _x('${postType.labels?.name}', 'Post Type General Name', '${textDomain}'),\n` : '') +
				(postType.labels?.singularName ? `    	'singular_name' => _x('${postType.labels?.singularName}', 'Post Type Singular Name', '${textDomain}'),\n` : '') +
				(postType.labels?.menuName ? `     	'menu_name' => _x('${postType.name}', 'Admin Menu text', '${textDomain}'),\n` : '') +
				(postType.labels ? `    ],\n` : '') +
				(postType.supports ? `		'supports' => [${postType.supports.map((support) => `'${support}'`).join(', ')}],\n` : '') +
				(postType.public !== undefined ? `    'public' => ${postType.public ? 'true' : 'false'},\n` : '') +
				(postType.hasArchive !== undefined ? `    'has_archive' => ${postType.hasArchive ? 'true' : 'false'},\n` : '') +
				(postType.showInRest !== undefined ? `    'show_in_rest' => ${postType.showInRest ? 'true' : 'false'},\n` : '') +
				`  ]);\n` +
				(!postType.gutenbergEnabled ? `  remove_post_type_support('${postType.name}', 'editor');\n` : '') +
				`});\n` +
				generateMetaBoxForPostType(postType).toString() +
				`// End Post Type ${postType.name}\n`;
		}).join('\n\n');
	}

	return output;
}

export function generateMetaBoxForPostType(postType: PostType) {
	let output = '\n';

	if (postType.fields) {
		// Create metabox
		output += 'add_action(\'add_meta_boxes\', function() {\n' +
			`  add_meta_box('${postType.name}_fields', '${postType.fieldsTitle || 'Fields'}', function($post) {\n` +
			`    echo '<table class="form-table" role="presentation">';\n` +
			`    echo '<tbody>';\n`;

		output += postType.fields.map((field) => {
			return `		$value = get_post_meta($post->ID, '${field.name}', true);\n` +
				`		echo '<tr><td class="first"><label for="${field.name}">${field.title}</label></td><td><input ${field.readOnly ? 'disabled ' : ''}style="width:100%" type="text" name="${field.name}" value="' . esc_attr($value) . '" /></td></tr>';\n`;
		}).join('');
		output += `    echo '</tbody></table>';\n` +
			`	 }, '${postType.name}', 'normal', 'default');\n` +
			'});\n';

		// Create save
		output += '\nadd_action(\'save_post\', function($post_id) {\n' +
			`  if ( '${postType.name}' !== get_post_type( $post_id ) ) return;\n`;
		output += postType.fields.map((field) => {
			return `	if (array_key_exists('${field.name}', $_POST)) {\n` +
				`		update_post_meta($post_id, '${field.name}', $_POST['${field.name}']);\n` +
				`	}\n`;
		}).join('');
		output += '});\n';
	}

	return output;
}